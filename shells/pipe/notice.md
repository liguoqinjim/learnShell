談到 pipe line ，我相信不少人都不會陌生： 
我們在很多 command line 上常看到的" | "符號就是 pipe line 了。 
不過，究竟 pipe line 是甚麼東東呢？ 
別急別急... 先查一下英漢字典，看看 pipe 是甚麼意思？ 
沒錯﹗它就是"水管"的意思... 
那麼，你能想像一下水管是怎麼一根接著一根的嗎？ 
又，每根水管之間的 input 跟 output 又如何呢？ 
嗯？？ 
靈光一閃：原來 pipe line 的 I/O 跟水管的 I/O 是一模一樣的： 
* 上一個命令的 stdout 接到下一個命令的 stdin 去了﹗ 
的確如此... 不管在 command line 上你使用了多少個 pipe line ， 
前後兩個 command 的 I/O 都是彼此連接的﹗(恭喜：你終於開竅了﹗ ^_^ ) 

不過... 然而... 但是... ... stderr 呢？ 
好問題﹗不過也容易理解： 
* 若水管漏水怎麼辦？ 
也就是說：在 pipe line 之間，前一個命令的 stderr 是不會接進下一命令的 stdin 的， 
其輸出，若不用 2> 導到 file 去的話，它還是送到監視器上面來﹗ 
這點請你在 pipe line 運用上務必要注意的。 

那，或許你又會問： 
* 有辦法將 stderr 也餵進下一個命令的 stdin 去嗎？ 
(貪得無厭的家夥﹗) 
方法當然是有，而且你早已學過了﹗ ^_^ 
我提示一下就好： 
* 請問你如何將 stderr 合併進 stdout 一同輸出呢？ 
若你答不出來，下課之後再來問我吧... (如果你臉皮真夠厚的話...) 

或許，你仍意尤未盡﹗或許，你曾經碰到過下面的問題： 
* 在 cm1 | cm2 | cm3 ... 這段 pipe line 中，若要將 cm2 的結果存到某一檔案呢？ 

若你寫成 cm1 | cm2 > file | cm3 的話， 
那你肯定會發現 cm3 的 stdin 是空的﹗(當然啦，你都將水管接到別的水池了﹗) 
聰明的你或許會如此解決： 
cm1 | cm2 > file ; cm3 < file
复制代码

是的，你的確可以這樣做，但最大的壞處是：這樣一來，file I/O 會變雙倍﹗ 
在 command 執行的整個過程中，file I/O 是最常見的最大效能殺手。 
凡是有經驗的 shell 操作者，都會盡量避免或降低 file I/O 的頻率。 

那，上面問題還有更好方法嗎？ 
有的，那就是 tee 命令了。 
* 所謂 tee 命令是在不影響原本 I/O 的情況下，將 stdout 複製一份到檔案去。 
因此，上面的命令行可以如此打： 
cm1 | cm2 | tee file | cm3
复制代码

在預設上，tee 會改寫目標檔案，若你要改為增加內容的話，那可用 -a 參數達成。 

基本上，pipe line 的應用在 shell 操作上是非常廣泛的，尤其是在 text filtering 方面， 
凡舉 cat, more, head, tail, wc, expand, tr, grep, sed, awk, ... 等等文字處理工具， 
搭配起 pipe line 來使用，你會驚覺 command line 原來是活得如此精彩的﹗ 
常讓人有"眾裡尋他千百度，驀然回首，那人卻在燈火闌珊處﹗"之感... ^_^ 